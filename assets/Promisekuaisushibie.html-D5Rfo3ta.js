import{_ as e,o,c,a as d}from"./app-BGYiCm6m.js";const i={},t=d('<h2 id="eventloop-事件队列" tabindex="-1"><a class="header-anchor" href="#eventloop-事件队列"><span>eventLoop(事件队列)</span></a></h2><ul><li>一开始整个脚本作为一个宏任务执行</li><li>执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列</li><li>当前宏任务执行完出队，检查微任务列表，有则依次执行，直到全部执行完</li><li>执行浏览器 UI 线程的渲染工作</li><li>检查是否有<code>Web Worker（独立于主线程运行的子线程）</code>任务，有则执行</li><li>执行完本轮的宏任务，回到 2，依此循环，直到宏任务和微任务队列都为空</li></ul><h2 id="宏任务" tabindex="-1"><a class="header-anchor" href="#宏任务"><span>宏任务</span></a></h2><p>​ setTimeout、setInterval、 setImmediate、script*（整体代码）、 <em>I/O</em> 操作、<em>UI</em> 渲染等。</p><p>​ setTimeout 这种类型的宏任务会留到下次执行宏任务时执行</p><h2 id="微任务" tabindex="-1"><a class="header-anchor" href="#微任务"><span>微任务</span></a></h2><p>​ <code>MutationObserver</code>、<code>Promise.then()或catch()</code>、<code>Promise为基础开发的其它技术，比如fetch API</code>、<code>V8</code>的垃圾回收过程、<code>Node独有的process.nextTick</code>。</p><p>​ <strong>宏任务队列可以有多个，微任务队列只有一个</strong>。当某个宏任务执行完后,会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务，如果没有，会读取宏任务队列中排在最前的任务，执行宏任务的过程中，遇到微任务，依次加入微任务队列。栈空后，再次读取微任务队列里的任务，依次类推。</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h2><ul><li><code>Promise</code>的状态一经改变就不能再改变。</li><li><code>.then</code>和<code>.catch</code>都会返回一个新的<code>Promise</code>。</li><li><code>catch</code>不管被连接到哪里，都能捕获上层未捕捉过的错误。</li><li>在<code>Promise</code>中，返回任意一个非 <code>promise</code> 的值都会被包裹成 <code>promise</code> 对象，例如<code>return 2</code>会被包装为<code>return Promise.resolve(2)</code>。</li><li><code>Promise</code> 的 <code>.then</code> 或者 <code>.catch</code> 可以被调用多次, 但如果<code>Promise</code>内部的状态一经改变，并且有了一个值，那么后续每次调用<code>.then</code>或者<code>.catch</code>的时候都会直接拿到该值。</li><li><code>.then</code> 或者 <code>.catch</code> 中 <code>return</code> 一个 <code>error</code> 对象并不会抛出错误，所以不会被后续的 <code>.catch</code> 捕获。</li><li><code>.then</code> 或 <code>.catch</code> 返回的值不能是 promise 本身，否则会造成死循环。</li><li><code>.then</code> 或者 <code>.catch</code> 的参数期望是函数，传入非函数则会发生值透传。</li><li><code>.then</code>方法是能接收两个参数的，第一个是处理成功的函数，第二个是处理失败的函数，再某些时候你可以认为<code>catch</code>是<code>.then</code>第二个参数的简便写法。</li><li><code>.finally</code>方法也是返回一个<code>Promise</code>，他在<code>Promise</code>结束的时候，无论结果为<code>resolved</code>还是<code>rejected</code>，都会执行里面的回调函数。</li><li><code>.all()</code>方法传入一个Promise，如果状态为成功则返回一个数组。数组元素不是Promise会被.Resolve方法转换为Promise对象，数组结果顺序和传入顺序一致，否则为reject返回</li></ul>',10),l=[t];function r(a,s){return o(),c("div",null,l)}const h=e(i,[["render",r],["__file","Promisekuaisushibie.html.vue"]]),m=JSON.parse('{"path":"/blogs/JavaScript/Promisekuaisushibie.html","title":"Promise快速识别","lang":"en-US","frontmatter":{"title":"Promise快速识别","date":"2023-02-15T00:00:00.000Z","tags":["JavaScript"],"categories":["JavaScript"]},"headers":[{"level":2,"title":"eventLoop(事件队列)","slug":"eventloop-事件队列","link":"#eventloop-事件队列","children":[]},{"level":2,"title":"宏任务","slug":"宏任务","link":"#宏任务","children":[]},{"level":2,"title":"微任务","slug":"微任务","link":"#微任务","children":[]},{"level":2,"title":"总结","slug":"总结","link":"#总结","children":[]}],"git":{"createdTime":null,"updatedTime":null,"contributors":[]},"filePathRelative":"blogs/JavaScript/Promise快速识别.md"}');export{h as comp,m as data};
